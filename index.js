#!/usr/bin/env node

// built-ins
const util = require('util')
const wait = util.promisify(setTimeout)

// npm modules
const inquirer = require('inquirer')
const callbackGrowl = require('growl')
const growl = util.promisify(callbackGrowl)
const dnd = require('@sindresorhus/do-not-disturb')
const ora = require('ora')
require('loud-rejection/register')

const growlArgs = {
  title: 'loops',
  name: 'loops',
  sticky: true,
  sound: 'pop',
  priority: 2
}

let loopCount = 0

const debug = (message, key) => {
  // Provide "true" to log all debug, or a component name to log just that component
  if (key && process.env.debug === key) {
    console.log(message)
  } else if (process.env.debug === 'true') {
    console.log(message)
  }
}

const handleReadable = async (spinner, answers) => {
  while ((chunk = process.stdin.read()) !== null) {}
  try {
    spinner && spinner.stop()
  } catch (e) {
    console.log(e)
    console.log(spinner)
  }
  process.stdin.removeListener('readable', handleReadable)
  const localAnswers = await inquirer.prompt({
    type: 'confirm',
    name: 'cancel',
    message: 'Do you want to cancel this loop?',
    default: false,
    askAnswered: true
  })

  if (localAnswers.cancel) {
    spinner.fail('Work cancelled.')
    await reflection()
    entryPoint(answers)
  } else {
    spinner.start('Working...')
    registerListener(spinner, answers)
  }
}

const registerListener = (spinner, answers) => {
  process.stdin.on('readable', handleReadable.bind(null, spinner, answers))
}

const workLoop = async (answers) => {
  debug(`Starting a work loop with a length of ${parseFloat(answers.workLength)} minutes.`)
  const spinner = ora('Working...').start()
  // calling workLoop turns on do not disturb, which hides the notification generated by breakLoop
  // so, let's wait 5 seconds after we start "working" to enable DND and thus hide the notification
  setTimeout(dnd.enable, 2000)
  registerListener(spinner, answers)
  await wait(parseFloat(answers.workLength)*60*1000)
  process.stdin.removeListener('readable', handleReadable)
  spinner.succeed('Worked.')
  await dnd.disable()
  await growl('Work loop complete! Time to reflect.', growlArgs)
}

const reflection = async () => {
  process.stdin.removeListener('readable', handleReadable)
  const answers = await inquirer.prompt([
    {
      type: 'input',
      name: 'todo',
      message: 'What new things do you need to do?'
    }
  ])
}

const breakLoop = async (answers) => {
  // this conditional is exactly the same as the one below, but we want to log out the info
  // before we start the spinner so it renders cleanly
  if(answers.enableSuperBreaks && loopCount % answers.superBreakModulo === 0) {
    debug(`Starting a super break with a length of ${parseFloat(answers.superBreakLength)} minutes.`)
  } else {
    debug(`Starting a normal break with a length of ${parseFloat(answers.breakLength)} minutes.`)
  }

  const spinner = ora('Relaxing...').start()

  if(answers.enableSuperBreaks && loopCount % answers.superBreakModulo === 0) {
    await wait(parseFloat(answers.superBreakLength)*60*1000)
  } else {
    await wait(parseFloat(answers.breakLength)*60*1000)
  }

  spinner.succeed('Relaxed.')
  await dnd.disable()
  await growl('Break complete! Time to start another loop.', growlArgs)
}

const main = async () => {
  const answers = await inquirer.prompt([
    {
      type: 'input',
      name: 'workLength',
      message: 'How many minutes long should the work units be?',
      default: '30',
      validate: (input) => isNaN(parseFloat(input)) ? 'Please input a number.' : true
    },
    {
      type: 'input',
      name: 'breakLength',
      message: 'How many minutes long should the breaks between work units be?',
      default: '4',
      validate: (input) => isNaN(parseFloat(input)) ? 'Please input a number.' : true
    },
    {
      type: 'confirm',
      name: 'enableSuperBreaks',
      message: 'Do you want to take a longer break every few breaks?',
      default: true
    },
    {
      type: 'list',
      name: 'superBreakModulo',
      message: 'How often do you want to take a longer break?',
      default: 2,
      when: (answers) => { return answers.enableSuperBreaks },
      choices: [
        {
          name: 'Every other break',
          short: 'Every other',
          value: 2
        },
        {
          name: 'Every third break',
          short: 'Every third',
          value: 3
        },
        {
          name: 'Every fourth break',
          short: 'Every fourth',
          value: 4
        },
        {
          name: 'Every fifth break',
          short: 'Every fifth',
          value: 5
        }
      ]
    },
    {
      type: 'input',
      name: 'superBreakLength',
      message: 'How many minutes long should a long break be?',
      default: '30',
      when: (answers) => answers.enableSuperBreaks,
      validate: (input) => isNaN(parseFloat(input)) ? 'Please input a number.' : true
    }
  ])

  debug(console.log(JSON.stringify(answers, null, 2)))

  entryPoint(answers)
}

const entryPoint = async (answers) => {
  while(true) {
    loopCount++
    await workLoop(answers)
    await reflection()
    await breakLoop(answers)
  }
}

main()
